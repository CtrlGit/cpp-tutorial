# メモリの動的確保
C言語では`malloc()`とか`calloc()`を使ってメモリの動的確保をしてきた。C++ではメモリの確保・解放の構文が新しく追加された。

## `malloc()`と`free()`のおさらい
C言語では以下のようにしてメモリの動的確保を行った。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
	// メモリ動的確保
	int* p = (int*)malloc(100 * sizeof(int));

	// ポインタ経由でメモリにアクセス
	p[19] = 114514;
	printf("%d\n", p[19]);

	// メモリ解放
	free(p);

	return 0;
}
```

~~Cはいいから早くC++見せろや~~

## C++で動的確保(1つだけ)
`new`演算子と`delete`演算子を使ってメモリの動的確保・解放ができます。まずは1つだけ確保するバージョン。

### 構文

```cpp
// 確保
型* ポインタ変数名 = new 型(コンストラクタ引数リスト);

// 解放
delete ポインタ変数名;
```

### 例

```cpp
#include <iostream>
using namespace std;

int main() {
	// メモリ動的確保
	int* p = new int;

	// ポインタ経由でメモリにアクセス
	*p = 114514;
	cout << *p << '\n';

	// メモリ解放
	delete p;

	return 0;
}
```

### 実行結果
> 114514

### 解説
変数1つぶんだけ確保出来ました。やったぜ。

一番注意するべきことは、`delete`で開放することを忘れないこと。忘れるとメモリリークします。

コンストラクタ云々は次節で。

## クラスのインスタンスを動的に生成
`new`でクラスのインスタンスを生成することもできます。コンストラクタの引数を指定することができます。`delete`した時点でデストラクタが呼ばれます。

### 例

```cpp
Person* p = new Person("田所浩二", "学生", 24); // 確保
(*p).print();
delete p; // 解放する直前にデストラクタが呼ばれる

p = new Person("谷岡俊一", "ヤクザ", 26); // 確保
(*p).print();
delete p; // 解放する直前にデストラクタが呼ばれる
```

### 実行結果
> 田所浩二「24歳、学生です。」  
> やったぜ。  
> 谷岡俊一「26歳、ヤクザです。」  
> やったぜ。

### 解説
解放するタイミングを自分で制御出来た(デストラクタを自分で呼べた)。ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!

ところで、

```cpp
(*hoge).piyo
```

とか書くの面倒くさくない？もっと簡単に見やすく書けるよ。

```cpp
hoge->piyo
```

この2つのコードは完全に等価。 ~~演算子をオーバーロードしなければね。~~ というわけで例を後者で書き換えてみよう

```cpp
Person* p = new Person("田所浩二", "学生", 24);
p->print();
delete p;

p = new Person("谷岡俊一", "ヤクザ", 26);
p->print();
delete p;
```

見やすくなった。ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!ｲｲﾈ!

実はこれC言語にもある演算子なんですよ・・・

## 配列の確保
`new`演算子と`delete`演算子を使って配列も動的確保・解放ができます。

### 構文

```cpp
// 確保
型* ポインタ変数名 = new 型[個数];

// 解放 (delete のあとの[]を忘れないように！忘れてもコンパイルは通ります)
delete[] ポインタ変数名;
```

### 例

```cpp
#include <iostream>
using namespace std;

int main() {
	// メモリ動的確保
	int* p = new int[100];

	// ポインタ経由でメモリにアクセス
	p[19] = 114514;
	cout << p[19] << '\n';

	// メモリ解放
	delete[] p;

	return 0;
}
```

### 実行結果
> 114514

### 解説
`malloc()`と`free()`を使ったやつよりずっとシンプル。C++ではほとんど`new`と`delete`によるメモリの動的確保・解放が行われます。

一番注意するべきことは、動的に確保した配列を`delete`で開放するとき、`delete`のあとに`[]`を必ず書くこと。書かないと死にます。

一応`cstdlib`をincludeすればC++でも`malloc()`や`free()`は使えます。ただし、

- `malloc()`で確保したメモリは`free()`で解放する
- `new`で確保したメモリは`delete`で解放する

ということを守ってください。

- `malloc()`で確保したメモリを`delete`で解放する
- `new`で確保したメモリを`free()`で解放する

といったことはしないでくだしあ。

## インスタンスの配列

クラスのインスタンスの配列を作るときは、**引数なしのコンストラクタ(デフォルトコンストラクタでも可)が存在する必要があります。**

```cpp
// Person クラスに引数なしのコンストラクタがなければコンパイルエラー
Person* p = new Person[100];

for (int i = 0; i < 100; i++) {
	p[i].print();
}

delete[] p;
```

それだけ注意。

<[前に戻る](05-ConstructorDestructor.md) - [目次へ](../../README.md) - 次へ進む>
