# コンストラクタとデストラクタ
建設業者と破壊装置。クラスに備え付けられた機能です。これも見たほうが早い。

## コンストラクタ
今まで作ってきた`Person`クラス。以下のように

```cpp
Person p;
```

インスタンスを生成した直後は、`name`や`job`、`old`などのメンバ変数は初期化されていません。中には適当なゴミデータが入っているでしょう。

このまま`print()`関数を呼んだらどうなるでしょうか？恐らくグチャグチャなデータが出力されるんじゃない？(適当)

「初期化すれば解決だよね」と思った人は、C言語を十分に理解している人だと思います(多分)。そう、初期化で解決です。でも、いちいち全部`setなんちゃら`関数を呼ぶのは面倒臭い・・・インスタンスが複数あったとき同じ処理を何回も書くのは嫌だ・・・インスタンス生成した時に勝手に初期化する仕組み無いのかな・・・

あります。C++ には、インスタンスを初期化する機能「コンストラクタ」があります。コンストラクタは、クラスに定義する特殊な関数です。インスタンスを作った時に呼ばれます。実際に見てみよう

### 構文

```cpp
class クラス名 {
アクセス指定子:
	クラス名(引数リスト); // 戻り値なし(void すら書かない!)で関数名がクラス名の関数
};

クラス名::クラス名(引数リスト) {
	// 初期化処理
}
```

### 例

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
	string name;
	string job;
	int old;

public:
	Person(); // コンストラクタ。初期化処理をする

	void setName(string n);
	void setJob(string j);
	void setOld(int o);
	void print();
};

// コンストラクタ
Person::Person() {
	// 基本的にここで初期化する
	cout << "Personを初期化するよ!\n";
	name = "無名";
	job = "無職";
	old = 0;
}

// その他のメンバ関数は省略(以前と同じ)

int main() {
	Person pEmpty; // インスタンス生成時にコンストラクタが呼ばれる
	cout << "初期化終わり!\n";
	pEmpty.print();

	return 0;
}
```

### 実行結果
> Personを初期化するよ!  
> 初期化終わり!  
> 無名「0歳、無職です。」

### 解説
解説要るかなぁ？

一応定義方法。戻り値なし(voidすら書かない)で、関数名がクラス名である関数を書くとそれがコンストラクタになる。基本的にコンストラクタ内ではメンバ変数の初期化を行う。関数と言うからには・・・

## コンストラクタのオーバーロード
オーバーロードできます。つまり、コンストラクタに引数を付けることができます。引数付きコンストラクタの宣言方法はもう察しがつくと思うけど、インスタンスの生成方法がちょっと変わってる。

### 例

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
	string name;
	string job;
	int old;

public:
	// コンストラクタ
	Person();
	Person(string n, string j, int o); // 引数付きコンストラクタ

	void setName(string n);
	void setJob(string j);
	void setOld(int o);
	void print();
};

// コンストラクタ
Person::Person() {
	name = "無名";
	job = "無職";
	old = 0;
}
Person::Person(string n, string j, int o) {
	name = n;
	job = j;
	old = o;
}

// その他のメンバ関数は省略(以前と同じ)

int main() {
	Person pEmpty;
	pEmpty.print();

	// 引数付きコンストラクタの呼び出し方。インスタンス変数名のあとに括弧を付けて呼び出す
	Person pYJSNPI("田所浩二", "学生", 24);
	pYJSNPI.print();

	return 0;
}
```

### 実行結果
> 無名「0歳、無職です。」  
> 田所浩二「24歳、学生です。」

### 解説
引数付きコンストラクタを呼び出すには、インスタンス変数の宣言の直後に括弧を付けて関数みたいに引数を指定する。ちょっとだけ呼び出し方法に癖があるので注意。

このことから、引数なしのコンストラクタは、

```cpp
Person pEmpty;
```

でも、

```cpp
Person pEmpty();
```

でも意味は同じ。と思ったそこのあなた！残念、 **不正解です。** 前者しかコンパイルは通りません。気になった人は実験してみるといいでしょう。

後者は関数のプロトタイプ宣言にしか見えないんだよなぁ・・・

## デフォルトコンストラクタ
コンストラクタを **ひとつも** 宣言しないと、「アクセス指定子が`public`で引数なしの中身が空っぽのコンストラクタ」をコンパイラが自動生成してくれます。これをデフォルトコンストラクタといいます。

逆に、コンストラクタを **ひとつでも** 宣言すると、デフォルトコンストラクタは生成されません。つまり

```cpp
class Person {
	// 〜略〜
public:
	// コンストラクタはこれだけ
	Person(string n, string j, int o);
	// 〜略〜
}
// 〜略〜
int main() {
	Person pEmpty; // 引数なしのコンストラクタが無いからコンパイルエラー
	pEmpty.print();
	return 0;
}
```

このように、引数ありのコンストラクタのみが宣言されているときに、引数なしのコンストラクタは呼び出せなくなります。よく陥りやすい(と思う)ので注意してください。

## デストラクタ
デストラクタは、インスタンスがメモリから解放される直前に呼ばれる関数です。勝手に呼ばれます。戻り値・引数ともにありません。

### 構文

```cpp
class クラス名 {
アクセス指定子:
	~クラス名(); // デストラクタ。戻り値・引数無し(括弧は書く)
};

クラス名::~クラス名() {
	// 解放処理
}
```

### 例

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
	string name;
	string job;
	int old;

public:
	// コンストラクタ
	Person(string n, string j, int o);

	// デストラクタ
	~Person();

	void setName(string n);
	void setJob(string j);
	void setOld(int o);
	void print();
};

// コンストラクタ
Person::Person(string n, string j, int o) {
	name = n;
	job = j;
	old = o;
}

// デストラクタ
Person::~Person() {
	// 基本的にここで開放する
	cout << "やったぜ。\n";
}

// その他のメンバ関数は省略(以前と同じ)

int main() {
	Person pYJSNPI("田所浩二", "学生", 24);
	pYJSNPI.print();

	return 0;
} // スコープを抜けるとデストラクタが呼ばれる
```

### 実行結果
> 田所浩二「24歳、学生です。」  
> やったぜ。

### 解説
デストラクタでは、基本的にメモリなどの解放を行います。「解放って何するんだよ」っていう声が聞こえてきそうだけどよくよく考えてみて。

例えば、C言語でメモリを動的に確保するときに、`malloc()`とか`calloc()`とかいう関数使ったよね。で、一番最後に忘れてはいけないのが`free()`関数の呼び出し。これをしないとヤバい。大変だ。

例えば、C言語でファイルを読み書きするときに、`fopen()`とかいう関数使ったよね。で、一番最後に忘れてはいけないのが`fclose()`関数の呼び出し。これをしないと多分ヤバい。大変だ。

そう、デストラクタで`free()`関数や`fclose()`関数みたいなのを呼び出すようにすれば、インスタンスが要らなくなった(スコープを抜けた)ときに自動でやってくれます。やったぜ。

デストラクタは自分で呼ぶことができません。メモリが解放される時に自動で呼ばれます。メモリの確保・解放を動的にやればいいんだけれども、それについてはまだ説明してないからまた今度。

<[前に戻る](04-ClassAccessibility.md) - [目次へ](../README.md) - [次へ進む](06-DynamicAllocation.md)>
